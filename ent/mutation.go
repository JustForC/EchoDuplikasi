// Code generated by entc, DO NOT EDIT.

package ent

import (
	"Kynesia/ent/predicate"
	"Kynesia/ent/register"
	"Kynesia/ent/scholarship"
	"Kynesia/ent/user"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBiodata     = "Biodata"
	TypeRegister    = "Register"
	TypeScholarship = "Scholarship"
	TypeUser        = "User"
)

// BiodataMutation represents an operation that mutates the Biodata nodes in the graph.
type BiodataMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Biodata, error)
	predicates    []predicate.Biodata
}

var _ ent.Mutation = (*BiodataMutation)(nil)

// biodataOption allows management of the mutation configuration using functional options.
type biodataOption func(*BiodataMutation)

// newBiodataMutation creates new mutation for the Biodata entity.
func newBiodataMutation(c config, op Op, opts ...biodataOption) *BiodataMutation {
	m := &BiodataMutation{
		config:        c,
		op:            op,
		typ:           TypeBiodata,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBiodataID sets the ID field of the mutation.
func withBiodataID(id int) biodataOption {
	return func(m *BiodataMutation) {
		var (
			err   error
			once  sync.Once
			value *Biodata
		)
		m.oldValue = func(ctx context.Context) (*Biodata, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Biodata.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBiodata sets the old Biodata of the mutation.
func withBiodata(node *Biodata) biodataOption {
	return func(m *BiodataMutation) {
		m.oldValue = func(context.Context) (*Biodata, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BiodataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BiodataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BiodataMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BiodataMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Biodata.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the BiodataMutation builder.
func (m *BiodataMutation) Where(ps ...predicate.Biodata) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BiodataMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Biodata).
func (m *BiodataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BiodataMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BiodataMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BiodataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Biodata field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BiodataMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Biodata field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BiodataMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BiodataMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BiodataMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Biodata numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BiodataMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BiodataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BiodataMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Biodata nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BiodataMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Biodata field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BiodataMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BiodataMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BiodataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BiodataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BiodataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BiodataMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BiodataMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Biodata unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BiodataMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Biodata edge %s", name)
}

// RegisterMutation represents an operation that mutates the Register nodes in the graph.
type RegisterMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	statusOne          *int
	addstatusOne       *int
	statusTwo          *int
	addstatusTwo       *int
	onlineInterview    *string
	interviewTime      *time.Time
	clearedFields      map[string]struct{}
	user               *int
	cleareduser        bool
	scholarship        *int
	clearedscholarship bool
	done               bool
	oldValue           func(context.Context) (*Register, error)
	predicates         []predicate.Register
}

var _ ent.Mutation = (*RegisterMutation)(nil)

// registerOption allows management of the mutation configuration using functional options.
type registerOption func(*RegisterMutation)

// newRegisterMutation creates new mutation for the Register entity.
func newRegisterMutation(c config, op Op, opts ...registerOption) *RegisterMutation {
	m := &RegisterMutation{
		config:        c,
		op:            op,
		typ:           TypeRegister,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRegisterID sets the ID field of the mutation.
func withRegisterID(id int) registerOption {
	return func(m *RegisterMutation) {
		var (
			err   error
			once  sync.Once
			value *Register
		)
		m.oldValue = func(ctx context.Context) (*Register, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Register.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRegister sets the old Register of the mutation.
func withRegister(node *Register) registerOption {
	return func(m *RegisterMutation) {
		m.oldValue = func(context.Context) (*Register, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RegisterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RegisterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RegisterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RegisterMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Register.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatusOne sets the "statusOne" field.
func (m *RegisterMutation) SetStatusOne(i int) {
	m.statusOne = &i
	m.addstatusOne = nil
}

// StatusOne returns the value of the "statusOne" field in the mutation.
func (m *RegisterMutation) StatusOne() (r int, exists bool) {
	v := m.statusOne
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusOne returns the old "statusOne" field's value of the Register entity.
// If the Register object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegisterMutation) OldStatusOne(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusOne is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusOne requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusOne: %w", err)
	}
	return oldValue.StatusOne, nil
}

// AddStatusOne adds i to the "statusOne" field.
func (m *RegisterMutation) AddStatusOne(i int) {
	if m.addstatusOne != nil {
		*m.addstatusOne += i
	} else {
		m.addstatusOne = &i
	}
}

// AddedStatusOne returns the value that was added to the "statusOne" field in this mutation.
func (m *RegisterMutation) AddedStatusOne() (r int, exists bool) {
	v := m.addstatusOne
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatusOne resets all changes to the "statusOne" field.
func (m *RegisterMutation) ResetStatusOne() {
	m.statusOne = nil
	m.addstatusOne = nil
}

// SetStatusTwo sets the "statusTwo" field.
func (m *RegisterMutation) SetStatusTwo(i int) {
	m.statusTwo = &i
	m.addstatusTwo = nil
}

// StatusTwo returns the value of the "statusTwo" field in the mutation.
func (m *RegisterMutation) StatusTwo() (r int, exists bool) {
	v := m.statusTwo
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusTwo returns the old "statusTwo" field's value of the Register entity.
// If the Register object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegisterMutation) OldStatusTwo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusTwo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusTwo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusTwo: %w", err)
	}
	return oldValue.StatusTwo, nil
}

// AddStatusTwo adds i to the "statusTwo" field.
func (m *RegisterMutation) AddStatusTwo(i int) {
	if m.addstatusTwo != nil {
		*m.addstatusTwo += i
	} else {
		m.addstatusTwo = &i
	}
}

// AddedStatusTwo returns the value that was added to the "statusTwo" field in this mutation.
func (m *RegisterMutation) AddedStatusTwo() (r int, exists bool) {
	v := m.addstatusTwo
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatusTwo resets all changes to the "statusTwo" field.
func (m *RegisterMutation) ResetStatusTwo() {
	m.statusTwo = nil
	m.addstatusTwo = nil
}

// SetOnlineInterview sets the "onlineInterview" field.
func (m *RegisterMutation) SetOnlineInterview(s string) {
	m.onlineInterview = &s
}

// OnlineInterview returns the value of the "onlineInterview" field in the mutation.
func (m *RegisterMutation) OnlineInterview() (r string, exists bool) {
	v := m.onlineInterview
	if v == nil {
		return
	}
	return *v, true
}

// OldOnlineInterview returns the old "onlineInterview" field's value of the Register entity.
// If the Register object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegisterMutation) OldOnlineInterview(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOnlineInterview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOnlineInterview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnlineInterview: %w", err)
	}
	return oldValue.OnlineInterview, nil
}

// ClearOnlineInterview clears the value of the "onlineInterview" field.
func (m *RegisterMutation) ClearOnlineInterview() {
	m.onlineInterview = nil
	m.clearedFields[register.FieldOnlineInterview] = struct{}{}
}

// OnlineInterviewCleared returns if the "onlineInterview" field was cleared in this mutation.
func (m *RegisterMutation) OnlineInterviewCleared() bool {
	_, ok := m.clearedFields[register.FieldOnlineInterview]
	return ok
}

// ResetOnlineInterview resets all changes to the "onlineInterview" field.
func (m *RegisterMutation) ResetOnlineInterview() {
	m.onlineInterview = nil
	delete(m.clearedFields, register.FieldOnlineInterview)
}

// SetInterviewTime sets the "interviewTime" field.
func (m *RegisterMutation) SetInterviewTime(t time.Time) {
	m.interviewTime = &t
}

// InterviewTime returns the value of the "interviewTime" field in the mutation.
func (m *RegisterMutation) InterviewTime() (r time.Time, exists bool) {
	v := m.interviewTime
	if v == nil {
		return
	}
	return *v, true
}

// OldInterviewTime returns the old "interviewTime" field's value of the Register entity.
// If the Register object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegisterMutation) OldInterviewTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterviewTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterviewTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterviewTime: %w", err)
	}
	return oldValue.InterviewTime, nil
}

// ClearInterviewTime clears the value of the "interviewTime" field.
func (m *RegisterMutation) ClearInterviewTime() {
	m.interviewTime = nil
	m.clearedFields[register.FieldInterviewTime] = struct{}{}
}

// InterviewTimeCleared returns if the "interviewTime" field was cleared in this mutation.
func (m *RegisterMutation) InterviewTimeCleared() bool {
	_, ok := m.clearedFields[register.FieldInterviewTime]
	return ok
}

// ResetInterviewTime resets all changes to the "interviewTime" field.
func (m *RegisterMutation) ResetInterviewTime() {
	m.interviewTime = nil
	delete(m.clearedFields, register.FieldInterviewTime)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *RegisterMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *RegisterMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *RegisterMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *RegisterMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *RegisterMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *RegisterMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetScholarshipID sets the "scholarship" edge to the Scholarship entity by id.
func (m *RegisterMutation) SetScholarshipID(id int) {
	m.scholarship = &id
}

// ClearScholarship clears the "scholarship" edge to the Scholarship entity.
func (m *RegisterMutation) ClearScholarship() {
	m.clearedscholarship = true
}

// ScholarshipCleared reports if the "scholarship" edge to the Scholarship entity was cleared.
func (m *RegisterMutation) ScholarshipCleared() bool {
	return m.clearedscholarship
}

// ScholarshipID returns the "scholarship" edge ID in the mutation.
func (m *RegisterMutation) ScholarshipID() (id int, exists bool) {
	if m.scholarship != nil {
		return *m.scholarship, true
	}
	return
}

// ScholarshipIDs returns the "scholarship" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScholarshipID instead. It exists only for internal usage by the builders.
func (m *RegisterMutation) ScholarshipIDs() (ids []int) {
	if id := m.scholarship; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetScholarship resets all changes to the "scholarship" edge.
func (m *RegisterMutation) ResetScholarship() {
	m.scholarship = nil
	m.clearedscholarship = false
}

// Where appends a list predicates to the RegisterMutation builder.
func (m *RegisterMutation) Where(ps ...predicate.Register) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RegisterMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Register).
func (m *RegisterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RegisterMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.statusOne != nil {
		fields = append(fields, register.FieldStatusOne)
	}
	if m.statusTwo != nil {
		fields = append(fields, register.FieldStatusTwo)
	}
	if m.onlineInterview != nil {
		fields = append(fields, register.FieldOnlineInterview)
	}
	if m.interviewTime != nil {
		fields = append(fields, register.FieldInterviewTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RegisterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case register.FieldStatusOne:
		return m.StatusOne()
	case register.FieldStatusTwo:
		return m.StatusTwo()
	case register.FieldOnlineInterview:
		return m.OnlineInterview()
	case register.FieldInterviewTime:
		return m.InterviewTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RegisterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case register.FieldStatusOne:
		return m.OldStatusOne(ctx)
	case register.FieldStatusTwo:
		return m.OldStatusTwo(ctx)
	case register.FieldOnlineInterview:
		return m.OldOnlineInterview(ctx)
	case register.FieldInterviewTime:
		return m.OldInterviewTime(ctx)
	}
	return nil, fmt.Errorf("unknown Register field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RegisterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case register.FieldStatusOne:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusOne(v)
		return nil
	case register.FieldStatusTwo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusTwo(v)
		return nil
	case register.FieldOnlineInterview:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnlineInterview(v)
		return nil
	case register.FieldInterviewTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterviewTime(v)
		return nil
	}
	return fmt.Errorf("unknown Register field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RegisterMutation) AddedFields() []string {
	var fields []string
	if m.addstatusOne != nil {
		fields = append(fields, register.FieldStatusOne)
	}
	if m.addstatusTwo != nil {
		fields = append(fields, register.FieldStatusTwo)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RegisterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case register.FieldStatusOne:
		return m.AddedStatusOne()
	case register.FieldStatusTwo:
		return m.AddedStatusTwo()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RegisterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case register.FieldStatusOne:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatusOne(v)
		return nil
	case register.FieldStatusTwo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatusTwo(v)
		return nil
	}
	return fmt.Errorf("unknown Register numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RegisterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(register.FieldOnlineInterview) {
		fields = append(fields, register.FieldOnlineInterview)
	}
	if m.FieldCleared(register.FieldInterviewTime) {
		fields = append(fields, register.FieldInterviewTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RegisterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RegisterMutation) ClearField(name string) error {
	switch name {
	case register.FieldOnlineInterview:
		m.ClearOnlineInterview()
		return nil
	case register.FieldInterviewTime:
		m.ClearInterviewTime()
		return nil
	}
	return fmt.Errorf("unknown Register nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RegisterMutation) ResetField(name string) error {
	switch name {
	case register.FieldStatusOne:
		m.ResetStatusOne()
		return nil
	case register.FieldStatusTwo:
		m.ResetStatusTwo()
		return nil
	case register.FieldOnlineInterview:
		m.ResetOnlineInterview()
		return nil
	case register.FieldInterviewTime:
		m.ResetInterviewTime()
		return nil
	}
	return fmt.Errorf("unknown Register field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RegisterMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, register.EdgeUser)
	}
	if m.scholarship != nil {
		edges = append(edges, register.EdgeScholarship)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RegisterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case register.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case register.EdgeScholarship:
		if id := m.scholarship; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RegisterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RegisterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RegisterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, register.EdgeUser)
	}
	if m.clearedscholarship {
		edges = append(edges, register.EdgeScholarship)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RegisterMutation) EdgeCleared(name string) bool {
	switch name {
	case register.EdgeUser:
		return m.cleareduser
	case register.EdgeScholarship:
		return m.clearedscholarship
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RegisterMutation) ClearEdge(name string) error {
	switch name {
	case register.EdgeUser:
		m.ClearUser()
		return nil
	case register.EdgeScholarship:
		m.ClearScholarship()
		return nil
	}
	return fmt.Errorf("unknown Register unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RegisterMutation) ResetEdge(name string) error {
	switch name {
	case register.EdgeUser:
		m.ResetUser()
		return nil
	case register.EdgeScholarship:
		m.ResetScholarship()
		return nil
	}
	return fmt.Errorf("unknown Register edge %s", name)
}

// ScholarshipMutation represents an operation that mutates the Scholarship nodes in the graph.
type ScholarshipMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	startStepOne     *time.Time
	startStepTwo     *time.Time
	endStepOne       *time.Time
	endStepTwo       *time.Time
	announceStepOne  *time.Time
	announceStepTwo  *time.Time
	onlineTest       *string
	status           *int
	addstatus        *int
	clearedFields    map[string]struct{}
	registers        map[int]struct{}
	removedregisters map[int]struct{}
	clearedregisters bool
	done             bool
	oldValue         func(context.Context) (*Scholarship, error)
	predicates       []predicate.Scholarship
}

var _ ent.Mutation = (*ScholarshipMutation)(nil)

// scholarshipOption allows management of the mutation configuration using functional options.
type scholarshipOption func(*ScholarshipMutation)

// newScholarshipMutation creates new mutation for the Scholarship entity.
func newScholarshipMutation(c config, op Op, opts ...scholarshipOption) *ScholarshipMutation {
	m := &ScholarshipMutation{
		config:        c,
		op:            op,
		typ:           TypeScholarship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScholarshipID sets the ID field of the mutation.
func withScholarshipID(id int) scholarshipOption {
	return func(m *ScholarshipMutation) {
		var (
			err   error
			once  sync.Once
			value *Scholarship
		)
		m.oldValue = func(ctx context.Context) (*Scholarship, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Scholarship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScholarship sets the old Scholarship of the mutation.
func withScholarship(node *Scholarship) scholarshipOption {
	return func(m *ScholarshipMutation) {
		m.oldValue = func(context.Context) (*Scholarship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScholarshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScholarshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScholarshipMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScholarshipMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Scholarship.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ScholarshipMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ScholarshipMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Scholarship entity.
// If the Scholarship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScholarshipMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ScholarshipMutation) ResetName() {
	m.name = nil
}

// SetStartStepOne sets the "startStepOne" field.
func (m *ScholarshipMutation) SetStartStepOne(t time.Time) {
	m.startStepOne = &t
}

// StartStepOne returns the value of the "startStepOne" field in the mutation.
func (m *ScholarshipMutation) StartStepOne() (r time.Time, exists bool) {
	v := m.startStepOne
	if v == nil {
		return
	}
	return *v, true
}

// OldStartStepOne returns the old "startStepOne" field's value of the Scholarship entity.
// If the Scholarship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScholarshipMutation) OldStartStepOne(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartStepOne is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartStepOne requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartStepOne: %w", err)
	}
	return oldValue.StartStepOne, nil
}

// ResetStartStepOne resets all changes to the "startStepOne" field.
func (m *ScholarshipMutation) ResetStartStepOne() {
	m.startStepOne = nil
}

// SetStartStepTwo sets the "startStepTwo" field.
func (m *ScholarshipMutation) SetStartStepTwo(t time.Time) {
	m.startStepTwo = &t
}

// StartStepTwo returns the value of the "startStepTwo" field in the mutation.
func (m *ScholarshipMutation) StartStepTwo() (r time.Time, exists bool) {
	v := m.startStepTwo
	if v == nil {
		return
	}
	return *v, true
}

// OldStartStepTwo returns the old "startStepTwo" field's value of the Scholarship entity.
// If the Scholarship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScholarshipMutation) OldStartStepTwo(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartStepTwo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartStepTwo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartStepTwo: %w", err)
	}
	return oldValue.StartStepTwo, nil
}

// ResetStartStepTwo resets all changes to the "startStepTwo" field.
func (m *ScholarshipMutation) ResetStartStepTwo() {
	m.startStepTwo = nil
}

// SetEndStepOne sets the "endStepOne" field.
func (m *ScholarshipMutation) SetEndStepOne(t time.Time) {
	m.endStepOne = &t
}

// EndStepOne returns the value of the "endStepOne" field in the mutation.
func (m *ScholarshipMutation) EndStepOne() (r time.Time, exists bool) {
	v := m.endStepOne
	if v == nil {
		return
	}
	return *v, true
}

// OldEndStepOne returns the old "endStepOne" field's value of the Scholarship entity.
// If the Scholarship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScholarshipMutation) OldEndStepOne(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndStepOne is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndStepOne requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndStepOne: %w", err)
	}
	return oldValue.EndStepOne, nil
}

// ResetEndStepOne resets all changes to the "endStepOne" field.
func (m *ScholarshipMutation) ResetEndStepOne() {
	m.endStepOne = nil
}

// SetEndStepTwo sets the "endStepTwo" field.
func (m *ScholarshipMutation) SetEndStepTwo(t time.Time) {
	m.endStepTwo = &t
}

// EndStepTwo returns the value of the "endStepTwo" field in the mutation.
func (m *ScholarshipMutation) EndStepTwo() (r time.Time, exists bool) {
	v := m.endStepTwo
	if v == nil {
		return
	}
	return *v, true
}

// OldEndStepTwo returns the old "endStepTwo" field's value of the Scholarship entity.
// If the Scholarship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScholarshipMutation) OldEndStepTwo(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndStepTwo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndStepTwo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndStepTwo: %w", err)
	}
	return oldValue.EndStepTwo, nil
}

// ResetEndStepTwo resets all changes to the "endStepTwo" field.
func (m *ScholarshipMutation) ResetEndStepTwo() {
	m.endStepTwo = nil
}

// SetAnnounceStepOne sets the "announceStepOne" field.
func (m *ScholarshipMutation) SetAnnounceStepOne(t time.Time) {
	m.announceStepOne = &t
}

// AnnounceStepOne returns the value of the "announceStepOne" field in the mutation.
func (m *ScholarshipMutation) AnnounceStepOne() (r time.Time, exists bool) {
	v := m.announceStepOne
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnounceStepOne returns the old "announceStepOne" field's value of the Scholarship entity.
// If the Scholarship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScholarshipMutation) OldAnnounceStepOne(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnounceStepOne is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnounceStepOne requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnounceStepOne: %w", err)
	}
	return oldValue.AnnounceStepOne, nil
}

// ResetAnnounceStepOne resets all changes to the "announceStepOne" field.
func (m *ScholarshipMutation) ResetAnnounceStepOne() {
	m.announceStepOne = nil
}

// SetAnnounceStepTwo sets the "announceStepTwo" field.
func (m *ScholarshipMutation) SetAnnounceStepTwo(t time.Time) {
	m.announceStepTwo = &t
}

// AnnounceStepTwo returns the value of the "announceStepTwo" field in the mutation.
func (m *ScholarshipMutation) AnnounceStepTwo() (r time.Time, exists bool) {
	v := m.announceStepTwo
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnounceStepTwo returns the old "announceStepTwo" field's value of the Scholarship entity.
// If the Scholarship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScholarshipMutation) OldAnnounceStepTwo(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnounceStepTwo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnounceStepTwo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnounceStepTwo: %w", err)
	}
	return oldValue.AnnounceStepTwo, nil
}

// ResetAnnounceStepTwo resets all changes to the "announceStepTwo" field.
func (m *ScholarshipMutation) ResetAnnounceStepTwo() {
	m.announceStepTwo = nil
}

// SetOnlineTest sets the "onlineTest" field.
func (m *ScholarshipMutation) SetOnlineTest(s string) {
	m.onlineTest = &s
}

// OnlineTest returns the value of the "onlineTest" field in the mutation.
func (m *ScholarshipMutation) OnlineTest() (r string, exists bool) {
	v := m.onlineTest
	if v == nil {
		return
	}
	return *v, true
}

// OldOnlineTest returns the old "onlineTest" field's value of the Scholarship entity.
// If the Scholarship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScholarshipMutation) OldOnlineTest(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOnlineTest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOnlineTest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnlineTest: %w", err)
	}
	return oldValue.OnlineTest, nil
}

// ResetOnlineTest resets all changes to the "onlineTest" field.
func (m *ScholarshipMutation) ResetOnlineTest() {
	m.onlineTest = nil
}

// SetStatus sets the "status" field.
func (m *ScholarshipMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ScholarshipMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Scholarship entity.
// If the Scholarship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScholarshipMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ScholarshipMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ScholarshipMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ScholarshipMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// AddRegisterIDs adds the "registers" edge to the Register entity by ids.
func (m *ScholarshipMutation) AddRegisterIDs(ids ...int) {
	if m.registers == nil {
		m.registers = make(map[int]struct{})
	}
	for i := range ids {
		m.registers[ids[i]] = struct{}{}
	}
}

// ClearRegisters clears the "registers" edge to the Register entity.
func (m *ScholarshipMutation) ClearRegisters() {
	m.clearedregisters = true
}

// RegistersCleared reports if the "registers" edge to the Register entity was cleared.
func (m *ScholarshipMutation) RegistersCleared() bool {
	return m.clearedregisters
}

// RemoveRegisterIDs removes the "registers" edge to the Register entity by IDs.
func (m *ScholarshipMutation) RemoveRegisterIDs(ids ...int) {
	if m.removedregisters == nil {
		m.removedregisters = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.registers, ids[i])
		m.removedregisters[ids[i]] = struct{}{}
	}
}

// RemovedRegisters returns the removed IDs of the "registers" edge to the Register entity.
func (m *ScholarshipMutation) RemovedRegistersIDs() (ids []int) {
	for id := range m.removedregisters {
		ids = append(ids, id)
	}
	return
}

// RegistersIDs returns the "registers" edge IDs in the mutation.
func (m *ScholarshipMutation) RegistersIDs() (ids []int) {
	for id := range m.registers {
		ids = append(ids, id)
	}
	return
}

// ResetRegisters resets all changes to the "registers" edge.
func (m *ScholarshipMutation) ResetRegisters() {
	m.registers = nil
	m.clearedregisters = false
	m.removedregisters = nil
}

// Where appends a list predicates to the ScholarshipMutation builder.
func (m *ScholarshipMutation) Where(ps ...predicate.Scholarship) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ScholarshipMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Scholarship).
func (m *ScholarshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScholarshipMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, scholarship.FieldName)
	}
	if m.startStepOne != nil {
		fields = append(fields, scholarship.FieldStartStepOne)
	}
	if m.startStepTwo != nil {
		fields = append(fields, scholarship.FieldStartStepTwo)
	}
	if m.endStepOne != nil {
		fields = append(fields, scholarship.FieldEndStepOne)
	}
	if m.endStepTwo != nil {
		fields = append(fields, scholarship.FieldEndStepTwo)
	}
	if m.announceStepOne != nil {
		fields = append(fields, scholarship.FieldAnnounceStepOne)
	}
	if m.announceStepTwo != nil {
		fields = append(fields, scholarship.FieldAnnounceStepTwo)
	}
	if m.onlineTest != nil {
		fields = append(fields, scholarship.FieldOnlineTest)
	}
	if m.status != nil {
		fields = append(fields, scholarship.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScholarshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case scholarship.FieldName:
		return m.Name()
	case scholarship.FieldStartStepOne:
		return m.StartStepOne()
	case scholarship.FieldStartStepTwo:
		return m.StartStepTwo()
	case scholarship.FieldEndStepOne:
		return m.EndStepOne()
	case scholarship.FieldEndStepTwo:
		return m.EndStepTwo()
	case scholarship.FieldAnnounceStepOne:
		return m.AnnounceStepOne()
	case scholarship.FieldAnnounceStepTwo:
		return m.AnnounceStepTwo()
	case scholarship.FieldOnlineTest:
		return m.OnlineTest()
	case scholarship.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScholarshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case scholarship.FieldName:
		return m.OldName(ctx)
	case scholarship.FieldStartStepOne:
		return m.OldStartStepOne(ctx)
	case scholarship.FieldStartStepTwo:
		return m.OldStartStepTwo(ctx)
	case scholarship.FieldEndStepOne:
		return m.OldEndStepOne(ctx)
	case scholarship.FieldEndStepTwo:
		return m.OldEndStepTwo(ctx)
	case scholarship.FieldAnnounceStepOne:
		return m.OldAnnounceStepOne(ctx)
	case scholarship.FieldAnnounceStepTwo:
		return m.OldAnnounceStepTwo(ctx)
	case scholarship.FieldOnlineTest:
		return m.OldOnlineTest(ctx)
	case scholarship.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Scholarship field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScholarshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case scholarship.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case scholarship.FieldStartStepOne:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartStepOne(v)
		return nil
	case scholarship.FieldStartStepTwo:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartStepTwo(v)
		return nil
	case scholarship.FieldEndStepOne:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndStepOne(v)
		return nil
	case scholarship.FieldEndStepTwo:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndStepTwo(v)
		return nil
	case scholarship.FieldAnnounceStepOne:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnounceStepOne(v)
		return nil
	case scholarship.FieldAnnounceStepTwo:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnounceStepTwo(v)
		return nil
	case scholarship.FieldOnlineTest:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnlineTest(v)
		return nil
	case scholarship.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Scholarship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScholarshipMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, scholarship.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScholarshipMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case scholarship.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScholarshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	case scholarship.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Scholarship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScholarshipMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScholarshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScholarshipMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Scholarship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScholarshipMutation) ResetField(name string) error {
	switch name {
	case scholarship.FieldName:
		m.ResetName()
		return nil
	case scholarship.FieldStartStepOne:
		m.ResetStartStepOne()
		return nil
	case scholarship.FieldStartStepTwo:
		m.ResetStartStepTwo()
		return nil
	case scholarship.FieldEndStepOne:
		m.ResetEndStepOne()
		return nil
	case scholarship.FieldEndStepTwo:
		m.ResetEndStepTwo()
		return nil
	case scholarship.FieldAnnounceStepOne:
		m.ResetAnnounceStepOne()
		return nil
	case scholarship.FieldAnnounceStepTwo:
		m.ResetAnnounceStepTwo()
		return nil
	case scholarship.FieldOnlineTest:
		m.ResetOnlineTest()
		return nil
	case scholarship.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Scholarship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScholarshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.registers != nil {
		edges = append(edges, scholarship.EdgeRegisters)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScholarshipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case scholarship.EdgeRegisters:
		ids := make([]ent.Value, 0, len(m.registers))
		for id := range m.registers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScholarshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedregisters != nil {
		edges = append(edges, scholarship.EdgeRegisters)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScholarshipMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case scholarship.EdgeRegisters:
		ids := make([]ent.Value, 0, len(m.removedregisters))
		for id := range m.removedregisters {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScholarshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedregisters {
		edges = append(edges, scholarship.EdgeRegisters)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScholarshipMutation) EdgeCleared(name string) bool {
	switch name {
	case scholarship.EdgeRegisters:
		return m.clearedregisters
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScholarshipMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Scholarship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScholarshipMutation) ResetEdge(name string) error {
	switch name {
	case scholarship.EdgeRegisters:
		m.ResetRegisters()
		return nil
	}
	return fmt.Errorf("unknown Scholarship edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	email            *string
	password         *string
	role             *int
	addrole          *int
	clearedFields    map[string]struct{}
	registers        map[int]struct{}
	removedregisters map[int]struct{}
	clearedregisters bool
	done             bool
	oldValue         func(context.Context) (*User, error)
	predicates       []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(i int) {
	m.role = &i
	m.addrole = nil
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r int, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// AddRole adds i to the "role" field.
func (m *UserMutation) AddRole(i int) {
	if m.addrole != nil {
		*m.addrole += i
	} else {
		m.addrole = &i
	}
}

// AddedRole returns the value that was added to the "role" field in this mutation.
func (m *UserMutation) AddedRole() (r int, exists bool) {
	v := m.addrole
	if v == nil {
		return
	}
	return *v, true
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
	m.addrole = nil
}

// AddRegisterIDs adds the "registers" edge to the Register entity by ids.
func (m *UserMutation) AddRegisterIDs(ids ...int) {
	if m.registers == nil {
		m.registers = make(map[int]struct{})
	}
	for i := range ids {
		m.registers[ids[i]] = struct{}{}
	}
}

// ClearRegisters clears the "registers" edge to the Register entity.
func (m *UserMutation) ClearRegisters() {
	m.clearedregisters = true
}

// RegistersCleared reports if the "registers" edge to the Register entity was cleared.
func (m *UserMutation) RegistersCleared() bool {
	return m.clearedregisters
}

// RemoveRegisterIDs removes the "registers" edge to the Register entity by IDs.
func (m *UserMutation) RemoveRegisterIDs(ids ...int) {
	if m.removedregisters == nil {
		m.removedregisters = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.registers, ids[i])
		m.removedregisters[ids[i]] = struct{}{}
	}
}

// RemovedRegisters returns the removed IDs of the "registers" edge to the Register entity.
func (m *UserMutation) RemovedRegistersIDs() (ids []int) {
	for id := range m.removedregisters {
		ids = append(ids, id)
	}
	return
}

// RegistersIDs returns the "registers" edge IDs in the mutation.
func (m *UserMutation) RegistersIDs() (ids []int) {
	for id := range m.registers {
		ids = append(ids, id)
	}
	return
}

// ResetRegisters resets all changes to the "registers" edge.
func (m *UserMutation) ResetRegisters() {
	m.registers = nil
	m.clearedregisters = false
	m.removedregisters = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldRole:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addrole != nil {
		fields = append(fields, user.FieldRole)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldRole:
		return m.AddedRole()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldRole:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRole(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.registers != nil {
		edges = append(edges, user.EdgeRegisters)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRegisters:
		ids := make([]ent.Value, 0, len(m.registers))
		for id := range m.registers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedregisters != nil {
		edges = append(edges, user.EdgeRegisters)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRegisters:
		ids := make([]ent.Value, 0, len(m.removedregisters))
		for id := range m.removedregisters {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedregisters {
		edges = append(edges, user.EdgeRegisters)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeRegisters:
		return m.clearedregisters
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeRegisters:
		m.ResetRegisters()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
